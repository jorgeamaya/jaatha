% \VignetteIndexEntry{Using Jaatha with a custom simulation method}
% \VignetteDepends{jaatha}
% \VignettePackage{jaatha}
% \VignetteEngine{knitr::knitr}

\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{framed, color}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
jinfo <- packageDescription("jaatha")
opts_chunk$set(error = FALSE)
@

\hypersetup{
	pdftitle={Using Jaatha with a Custom Simulation Method \Sexpr{jinfo$Version}},
	pdfauthor={\Sexpr{jinfo$Author}},
	colorlinks=true,
	linkcolor=black,      % color of internal links
	citecolor=black,      % color of links to bibliography
	filecolor=black,      % color of file links
	urlcolor=blue         % color of external links
}

\begin{document}

\title{Using Jaatha with a Custom Simulation Method}
\author{\Sexpr{jinfo$Author}}
\maketitle

\section{Introduction}
\noindent
We originally designed Jaatha for Demographic Inference in Population 
Genetics\footnote{Please consult Jaatha's other vignette, ``The Jaatha HowTo'', if you
want to use Jaatha for Demographic Inference.}. 
As the algorithms turned out to work quite well there, we think that it might be
useful in other situations as well. Jaatha should work in the following
scenario:

\begin{itemize}
  \item You have data that is (assumed to be) generated by a parametric model
    and is -- at least approximately -- a sample from independent Poisson variables 
    under that model.
  \item You want maximum likelihood estimates for the parameter values
    generating your data, but the likelihood function is analytically
    untraceable. 
  \item You can simulate data for different parameter values under your model.
\end{itemize}

\noindent
In this document, we will explain how you can use Jaatha in such a situation and
provide step-by-step instructions for a toy example. We recommend that you first read
``The Jaatha HowTo'' or the current publication about Jaatha (\cite{mathew_why_2013}) to
understand how the algorithm works. 

The shown example code was produced with Jaatha version \Sexpr{jinfo$Version}.
Please either update this manual or Jaatha if you are using a different
version. Please note that the custom simulation interface changed
after version $2.1$ due to major internal restructurations. We are optimistic that
it will remain stable in the future. 

\section{Toy example}
\noindent
For the sake of simplicity, we will assume that the toy model consists of $30$
independent Poisson variables, where the first ten have mean $x$, the second
ten have mean $y$ and the last ten have mean $z$, with 
$x, y, z \in (0,\infty)$. For given values of $x$, $y$ and $z$ we can simulate
data under this model with the function:  

<<SetupModel>>=
sampleFromModel <- function(x, y, z){
  return( c(rpois(10, x), rpois(10, y), rpois(10, z)) )
}
@

\noindent
Assume we have observed data that originated from a model with true but
unknown parameters $x=3$, $y=5$ and $z=7.5$. Lets try to estimate these values 
again from the data.
<<SampleData>>=
set.seed(5)
data.observed <- sampleFromModel(3, 5, 7.5)
data.observed
@
\noindent
Of course, the arithmetic mean is a well-known unbiased, maximum likelihood estimator 
for $x$, $y$ and $z$ 
<<MLEstimates>>=
c(x=mean(data.observed[1:10]), 
  y=mean(data.observed[11:20]), 
  z=mean(data.observed[21:30]))
@

\noindent
but for the sake of this example, we will try using Jaatha for the estimation.



\section{Configuring Jaatha}
\noindent
We need three objects to run Jaatha
with our model:

\begin{itemize}
\item A list of observed summary statistics \verb@sum.stats@,
\item a function \verb@sim.func@ that simulates data according to our
      model and
\item A $n\times 2$-Matrix \verb@par.ranges@ that gives the minimal and maximal values for the
  $n$ model parameters.
\end{itemize}


\subsection{Observed summary statistics}
\noindent
Since version $2.2$ Jaatha supports using different independent groups summary
statistics, where each group either is an array of independent Poisson variables
or a vector valued transformation of an array, where the result vector again
consists of independent Poisson variables. The two types of summary statistics
are call \verb@poisson.independent@ and \verb@poisson.transformed@,
respectively. In our case, we can just stick to the first case.

To import the summary statistics in Jaatha, we create a list for each summary
statistic, in which \verb@method@ gives on the two types above, and \verb@value@
gives the observed values
<<create.poi.vec>>=
poisson.vector <- list(method='poisson.independent', 
                       value=data.observed)
@
\noindent
and combine all summary statistics into a list, indexed by a name
<<create.sum.stats>>=
sum.stats <- list(poisson.vector=poisson.vector)
@

\noindent
If we wanted to use the transformed type, say we wanted just to use the sum of
all $30$ vectors as summary statistics, we additionally need to give the
transformation
<<create.poi.sum>>=
poisson.sum <- list(method='poisson.transformation',
                    transformation=sum,
                    value=data.observed)
@
\noindent
and add this list to \verb@sum.stats@ instead.


\subsection{Simulation function}
\noindent
The function for the simulation must take exactly two arguments, first the
jaatha object and second a complete set of the $n$ model parameters. 
The function should do the simulation and return the simulated summary
statistics as a list, again indexed by the same names as in \verb@sum.stats@.
In our example $n = 3$ and we can write a simple wrapper functions for
\verb@sampleFromModel@ to give it the required form:
%
<<sim.func>>=
sim.func <- function(sim.pars, jaatha) {
  list(poisson.vector=sampleFromModel(sim.pars[1], sim.pars[2], sim.pars[3]))
}
# An example call
sim.func(sim.pars=1:3)
@

\noindent
Here we don't need the \verb@jaatha@ parameter. It could be used for passing 
additional parameters to the simulation function. We will explain how to do 
this in a moment.

\subsection{Parameter ranges}
\noindent
The matrix that gives the parameter ranges must be of dimension
$m\times 2$. Each row consists of the minimal and maximal values of the range that the parameter can
take. Restricting the range of the parameters is required at the moment. Jaatha
also reads the names of the parameters from this matrix, so providing row names
makes the output of Jaatha easier to read, but is not required for it to run. In
our example, the matrix could look like this:
<<par.ranges>>=
par.ranges <- matrix(c(0.1, 0.1, 0.1, 10, 10, 10), 3, 2)
rownames(par.ranges) <- c('x', 'y', 'z')
colnames(par.ranges) <- c('min', 'max')
par.ranges
@


\subsection{Initialization}
\noindent
Now, we can use these three objects to initialize Jaatha:
<<initializeJaatha>>=
library(jaatha, quietly=TRUE)
jaatha <- new('Jaatha', sim.func, par.ranges, sum.stats) 
@

\noindent
From this point on, we can continue as described in ``The Jaatha HowTo'' by
calling \verb@Jaatha.initialSearch@ and a \verb@Jaatha.refinedSearch@. We will
do so in a moment, but first cover a few open points.

First, if you want pass additional variables to the simulation function, you can
use the \verb@opts@-slot of the jaatha object, which holds a normal list. So
say you don't want to hard code the ten variables per parameter in our model,
you could call
<<setAdditionalParameters>>=
jaatha@opts[['variable.number']] <- 10 
@
\noindent
after you created the jaatha object with \verb@new@, and use 
<<getAdditionalParameters>>=
jaatha@opts[['variable.number']]
@
\noindent
in \verb@sim.func@ to access it again. Note that this values must be the same
for all simulations. It is better to save variables need for the simulation
in the Jaatha object rather than in the normal R-Workspace, as this ensures 
that Jaatha call are reproducible as long as the same Jaatha-Object is used.  

Second, if your simulation requires temporary files, we strongly recommend to use 
the function \verb@jaatha:::getTempFile(``some.identifier'')@ to generate a file
name. This will makes sure that the different threats of Jaatha don't interact
if the program is run on multiple cores in parallel. 

Finally, the options \verb@use.shm@ for placing temporary files in memory, and
\verb@cores@ and \verb@sim.packes.size@ for parallelization are implement in the
base algorithm an can also be used along with your custom simulation function.
Just add the options to the \verb@new@ call. These options are 
described in \verb@?Jaatha.initialize@. 

\section{Running Jaatha}
\noindent
So, lets see how Jaatha performs in your toy example:
<<runJaatha, cache=TRUE>>=
jaatha <- Jaatha.initialSearch(jaatha, 100, 2)
jaatha <- Jaatha.refinedSearch(jaatha, 2, 100)
@

\noindent
Hence, Jaatha's best estimates are quite comparable to the direct maximum likelihoods
estimates for this simple model.

\bibliographystyle{plainnat}
%\inputencoding{utf8}
\bibliography{jaatha}
%\inputencoding{utf8}

\end{document}


