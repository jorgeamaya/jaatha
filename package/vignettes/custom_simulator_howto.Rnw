% \VignetteIndexEntry{Using Jaatha with a custom simulation method}
% \VignetteDepends{jaatha}
% \VignettePackage{jaatha}
% \VignetteEngine{knitr::knitr}

\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{hyperref}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
jinfo <- packageDescription("jaatha")
@

\hypersetup{
	pdftitle={Using Jaatha with a Custom Simulation Method \Sexpr{jinfo$Version}},
	pdfauthor={\Sexpr{jinfo$Author}},
	colorlinks=true,
	linkcolor=black,      % color of internal links
	citecolor=black,      % color of links to bibliography
	filecolor=black,      % color of file links
	urlcolor=blue         % color of external links
}

\begin{document}

\title{Using Jaatha with a Custom Simulation Method}
\author{\Sexpr{jinfo$Author}}
\date{Version \Sexpr{jinfo$Version}}
\maketitle

%\section{Introduction}
\noindent
We originally designed Jaatha for Demographic Inference in Population 
Genetics\footnote{Please consult Jaatha's other vignette, ``The Jaatha HowTo'', if you
want to use Jaatha in for Demographic Inference.}. 
As the algorithms turned out to work quite well there, we think that it might be
useful in other situations as well. Jaatha should work in the following
scenario:

\begin{itemize}
  \item You have data that is (assumed to be) generated by a parametric model
    and is -- at least approximately -- a sample from independent Poisson variables 
    under that model.
  \item You want maximum likelihood estimates for the parameter values
    generating your data, but the likelihood function is analytically
    untraceable. 
  \item You can simulate data for different parameter values under your model.
\end{itemize}

\noindent
In this document, we will explain how you can use Jaatha in such a situation and
provide step-by-step instructions for a toy example. We recommend that you first read
``The Jaatha HowTo'' or your current publication about Jaatha (\cite{mathew_why_2013}) to
understand how the algorithm works.

For the sake of simplicity, we will assume the toy model just consists of $30$
independent Poisson variables, where the first ten have mean $x$, the second
ten have mean $y$ and the last ten have mean $z$, with 
$x, y, z \in (0,\infty)$. For given values of $x$, $y$ and $z$ we can simulate
data under this model with the function:  

<<SetupModel>>=
sampleFromModel <- function(x, y, z){
  return( c(rpois(10, x), rpois(10, y), rpois(10, z)) )
}
@

Assume that we have observed data that was generated with the true, but
unknown parameters $x=3$, $y=5$ and $z=7.5$ which we want to estimate from the
observed data.
<<SampleData>>=
set.seed(5)
data.observed <- sampleFromModel(3, 5, 7.5)
data.observed
@
Of course, the arithmetic mean is a well-known unbiased, maximum likelihoods estimator 
for $x$, $y$ and $z$ 
<<MLEstimates>>=
c(x=mean(data.observed[1:10]), 
  y=mean(data.observed[11:20]), 
  z=mean(data.observed[21:30]))
@
but for this example, we will pretend that we could not analytically verify
this.

Additionally to the observed data \verb@data.observed@, we need two more objects to run Jaatha
with our model:
\begin{itemize}
\item A function \verb@sim.func@ that simulates data according to our
      model and
\item A $n\times 2$-Matrix that gives the minimal and maximal values for the
  $n$ parameters we want to estimate.
\end{itemize}

The function for the simulation must take exactly two arguments, first the
jaatha object and second a $n\times m$-Matrix, in which each of the $m$ rows is
a complete set of the $n$ model parameters. The function should do simulations for
each of this sets and return the simulated values, again as a Matrix with $m$
rows, each row giving the simulation result of the corresponding row in the
input matrix. 

In our example $n = 3$ and we can write a simple wrapper functions for
\verb@sampleFromModel@ to give it the required form:
%
<<sim.func>>=
sim.func <- function(jaatha, sim.pars) {
  t(apply(sim.pars, 1, function(x) sampleFromModel(x[1], x[2], x[3])))
}
# An example call
sim.pars <- matrix(1:6, 2, 3, byrow=TRUE)
print(sim.pars)
sim.func(sim.pars=sim.pars)
@
%
Here, we did not need the \verb@jaatha@ parameter. We could use it for instance
to pass additional parameters to the simulation function. How to do this will be
explained in a moment.

As mentioned, the matrix that gives the parameter ranges should be of dimension
$m\times 2$ given the minimal and maximal values of the range that the parameter can
take. Restricting the range of the parameters is required at the moment. Jaatha
also reads the names of the parameters from this matrix, so providing row names
makes the output of Jaatha easier to read, but is not required for it to run. In
our example, the matrix could look like this:
<<par.ranges>>=
par.ranges <- matrix(c(0.1, 0.1, 0.1, 10, 10, 10), 3, 2)
rownames(par.ranges) <- c('x', 'y', 'z')
colnames(par.ranges) <- c('min', 'max')
par.ranges
@

Now, we can use these three objects to initialize Jaatha:
<<initializeJaatha>>=
library(jaatha)
jaatha <- new('Jaatha', sim.func, par.ranges, data.observed) 
@

Form this point on, you can continue as described in ``The Jaatha HowTo'' by
calling \verb@Jaatha.initialSearch@ and a \verb@Jaatha.refinedSearch@. We will
do so in a moment, but first cover a few open points.

First, if you want pass additional variables to the simulation function, you can
use the \verb@opts@-slot of the jaatha object, which holds a normal list. So
say you don't want to hard code the ten variables per parameter in our model,
you could call
<<setAdditionalParameters>>=
jaatha@opts[['variable.number']] <- 10 
@
after you created the jaatha object with \verb@new@, and use 
<<getAdditionalParameters>>=
jaatha@opts[['variable.number']]
@
in \verb@sim.func@ to access this value. Note that this values must be the same
for all simulations. It is better to save this vales in the Jaatha object rather
than in the normal R-Workspace, as this ensures that Jaatha call are
reproducible as long as the same Jaatha-Object is used.  

Second, if your simulation requires temporary files, we strongly recommend to use 
the function \verb@jaatha:::getTempFile(``some.identifier'')@ to generate a file
name. This will makes sure that the different threats of Jaatha don't interact
if the program is run on multiple cores in parallel. 

Finally, the options \verb@use.shm@ for placing temporary files in memory, and
\verb@cores@ and \verb@sim.packes.size@ for parallelization are implement in the
base algorithm an can also be used along with your custom simulation function.
Just add the options to the \verb@new@ call. These options are 
described in \verb@?Jaatha.initialize@. 

\noindent
So, lets see how Jaatha performs in your toy example:
<<runJaatha, cache=TRUE>>=
jaatha <- Jaatha.initialSearch(jaatha, 100, 2)
jaatha <- Jaatha.refinedSearch(jaatha, 2, 100)
@

Hence, Jaatha's best estimates are quite comparable to the direct maximum likelihoods
estimates for this simple model.

\bibliographystyle{plainnat}
\inputencoding{utf8}
\bibliography{jaatha_utf8}
%\inputencoding{utf8}

\end{document}
